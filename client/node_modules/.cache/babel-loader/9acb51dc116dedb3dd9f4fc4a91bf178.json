{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\"use strict\";\n\nvar _ = require('underscore');\n\nvar errors = require('web3-core-helpers').errors;\n\nvar EventEmitter = require('eventemitter3');\n\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = null;\n  this.arguments = null;\n  this._reconnectIntervalId = null;\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n} // INHERIT\n\n\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nSubscription.prototype._validateArgs = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) subscription = {};\n  if (!subscription.params) subscription.params = 0;\n\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0]);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nSubscription.prototype._formatInput = function (args) {\n  var subscription = this.options.subscription;\n\n  if (!subscription) {\n    return args;\n  }\n\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n\n  var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nSubscription.prototype._formatOutput = function (result) {\n  var subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nSubscription.prototype._toPayload = function (args) {\n  var params = [];\n  this.callback = this._extractCallback(args);\n\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift(); // replace subscription with given name\n\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n\n    this._validateArgs(this.arguments);\n\n    args = []; // make empty after validation\n  } // re-add subscriptionName\n\n\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n\n  return {\n    method: this.options.type + '_subscribe',\n    params: params\n  };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\n\n\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.removeAllListeners();\n  clearInterval(this._reconnectIntervalId);\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\n\n\nSubscription.prototype.subscribe = function () {\n  var _this = this;\n\n  var args = Array.prototype.slice.call(arguments);\n\n  var payload = this._toPayload(args);\n\n  if (!payload) {\n    return this;\n  }\n\n  if (!this.options.requestManager.provider) {\n    var err1 = new Error('No provider set.');\n    this.callback(err1, null, this);\n    this.emit('error', err1);\n    return this;\n  } // throw error, if provider doesnt support subscriptions\n\n\n  if (!this.options.requestManager.provider.on) {\n    var err2 = new Error('The current provider doesn\\'t support subscriptions: ' + this.options.requestManager.provider.constructor.name);\n    this.callback(err2, null, this);\n    this.emit('error', err2);\n    return this;\n  } // if id is there unsubscribe first\n\n\n  if (this.id) {\n    this.unsubscribe();\n  } // store the params in the options object\n\n\n  this.options.params = payload.params[1]; // get past logs, if fromBlock is available\n\n  if (payload.params[0] === 'logs' && _.isObject(payload.params[1]) && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n    this.options.requestManager.send({\n      method: 'eth_getLogs',\n      params: [payload.params[1]]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          var output = _this._formatOutput(log);\n\n          _this.callback(null, output, _this);\n\n          _this.emit('data', output);\n        }); // TODO subscribe here? after the past logs?\n      } else {\n        _this.callback(err, null, _this);\n\n        _this.emit('error', err);\n      }\n    });\n  } // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n\n  if (typeof payload.params[1] === 'object') delete payload.params[1].fromBlock;\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result; // call callback on notifications\n\n      _this.options.requestManager.addSubscription(_this.id, payload.params[0], _this.options.type, function (err, result) {\n        if (!err) {\n          if (!_.isArray(result)) {\n            result = [result];\n          }\n\n          result.forEach(function (resultItem) {\n            var output = _this._formatOutput(resultItem);\n\n            if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            } else {\n              _this.emit('data', output);\n            } // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n            if (_.isFunction(_this.callback)) {\n              _this.callback(null, output, _this);\n            }\n          });\n        } else {\n          // unsubscribe, but keep listeners\n          _this.options.requestManager.removeSubscription(_this.id); // re-subscribe, if connection fails\n\n\n          if (_this.options.requestManager.provider.once) {\n            _this._reconnectIntervalId = setInterval(function () {\n              // TODO check if that makes sense!\n              if (_this.options.requestManager.provider.reconnect) {\n                _this.options.requestManager.provider.reconnect();\n              }\n            }, 500);\n\n            _this.options.requestManager.provider.once('connect', function () {\n              clearInterval(_this._reconnectIntervalId);\n\n              _this.subscribe(_this.callback);\n            });\n          }\n\n          _this.emit('error', err); // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n          if (_.isFunction(_this.callback)) {\n            _this.callback(err, null, _this);\n          }\n        }\n      });\n    } else if (_.isFunction(_this.callback)) {\n      _this.callback(err, null, _this);\n\n      _this.emit('error', err);\n    } else {\n      // emit the event even if no callback was provided\n      _this.emit('error', err);\n    }\n  }); // return an object to cancel the subscription\n\n  return this;\n};\n\nmodule.exports = Subscription;","map":{"version":3,"sources":["/Users/erick/eth/progpay/client/node_modules/drizzle/node_modules/web3-core-subscriptions/src/subscription.js"],"names":["_","require","errors","EventEmitter","Subscription","options","call","id","callback","arguments","_reconnectIntervalId","subscription","type","requestManager","prototype","Object","create","constructor","_extractCallback","args","isFunction","length","pop","_validateArgs","params","InvalidNumberOfParams","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","subscriptionName","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","clearInterval","subscribe","_this","Array","slice","payload","provider","err1","emit","on","err2","name","isObject","hasOwnProperty","isFinite","fromBlock","send","err","logs","forEach","log","output","addSubscription","isArray","resultItem","subscriptionHandler","once","setInterval","reconnect","module","exports"],"mappings":"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","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\n\n\nfunction Subscription(options) {\n    EventEmitter.call(this);\n\n    this.id = null;\n    this.callback = null;\n    this.arguments = null;\n    this._reconnectIntervalId = null;\n\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager\n    };\n}\n\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\nSubscription.prototype._validateArgs = function (args) {\n    var subscription = this.options.subscription;\n\n    if(!subscription)\n        subscription = {};\n\n    if(!subscription.params)\n        subscription.params = 0;\n\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0]);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\nSubscription.prototype._formatInput = function (args) {\n    var subscription = this.options.subscription;\n\n    if (!subscription) {\n        return args;\n    }\n\n    if (!subscription.inputFormatter) {\n        return args;\n    }\n\n    var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n        return formatter ? formatter(args[index]) : args[index];\n    });\n\n    return formattedArgs;\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\nSubscription.prototype._formatOutput = function (result) {\n    var subscription = this.options.subscription;\n\n    return (subscription && subscription.outputFormatter && result) ? subscription.outputFormatter(result) : result;\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n    var params = [];\n    this.callback = this._extractCallback(args);\n\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift();\n\n        // replace subscription with given name\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName;\n        }\n    }\n\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args);\n        this._validateArgs(this.arguments);\n        args = []; // make empty after validation\n\n    }\n\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod);\n    params = params.concat(this.arguments);\n\n\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n    }\n\n    return {\n        method: this.options.type + '_subscribe',\n        params: params\n    };\n};\n\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function(callback) {\n    this.options.requestManager.removeSubscription(this.id, callback);\n    this.id = null;\n    this.removeAllListeners();\n    clearInterval(this._reconnectIntervalId);\n};\n\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function() {\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments);\n    var payload = this._toPayload(args);\n\n    if(!payload) {\n        return this;\n    }\n\n    if(!this.options.requestManager.provider) {\n        var err1 = new Error('No provider set.');\n        this.callback(err1, null, this);\n        this.emit('error', err1);\n        return this;\n    }\n\n    // throw error, if provider doesnt support subscriptions\n    if(!this.options.requestManager.provider.on) {\n        var err2 = new Error('The current provider doesn\\'t support subscriptions: '+ this.options.requestManager.provider.constructor.name);\n        this.callback(err2, null, this);\n        this.emit('error', err2);\n        return this;\n    }\n\n    // if id is there unsubscribe first\n    if (this.id) {\n        this.unsubscribe();\n    }\n\n    // store the params in the options object\n    this.options.params = payload.params[1];\n\n    // get past logs, if fromBlock is available\n    if(payload.params[0] === 'logs' && _.isObject(payload.params[1]) && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n        // send the subscription request\n        this.options.requestManager.send({\n            method: 'eth_getLogs',\n            params: [payload.params[1]]\n        }, function (err, logs) {\n            if(!err) {\n                logs.forEach(function(log){\n                    var output = _this._formatOutput(log);\n                    _this.callback(null, output, _this);\n                    _this.emit('data', output);\n                });\n\n                // TODO subscribe here? after the past logs?\n\n            } else {\n                _this.callback(err, null, _this);\n                _this.emit('error', err);\n            }\n        });\n    }\n\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n\n    if(typeof payload.params[1] === 'object')\n        delete payload.params[1].fromBlock;\n\n    this.options.requestManager.send(payload, function (err, result) {\n        if(!err && result) {\n            _this.id = result;\n\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this.id, payload.params[0] , _this.options.type, function(err, result) {\n\n                if (!err) {\n                    if (!_.isArray(result)) {\n                        result = [result];\n                    }\n\n                    result.forEach(function(resultItem) {\n                        var output = _this._formatOutput(resultItem);\n\n                        if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output);\n                        } else {\n                            _this.emit('data', output);\n                        }\n\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        if (_.isFunction(_this.callback)) {\n                            _this.callback(null, output, _this);\n                        }\n                    });\n                } else {\n                    // unsubscribe, but keep listeners\n                    _this.options.requestManager.removeSubscription(_this.id);\n\n                    // re-subscribe, if connection fails\n                    if(_this.options.requestManager.provider.once) {\n                        _this._reconnectIntervalId = setInterval(function () {\n                            // TODO check if that makes sense!\n                            if (_this.options.requestManager.provider.reconnect) {\n                                _this.options.requestManager.provider.reconnect();\n                            }\n                        }, 500);\n\n                        _this.options.requestManager.provider.once('connect', function () {\n                            clearInterval(_this._reconnectIntervalId);\n                            _this.subscribe(_this.callback);\n                        });\n                    }\n                    _this.emit('error', err);\n\n                     // call the callback, last so that unsubscribe there won't affect the emit above\n                     if (_.isFunction(_this.callback)) {\n                        _this.callback(err, null, _this);\n                    }\n                }\n            });\n        } else if (_.isFunction(_this.callback)) {\n            _this.callback(err, null, _this);\n            _this.emit('error', err);\n        } else {\n            // emit the event even if no callback was provided\n            _this.emit('error', err);\n        }\n    });\n\n    // return an object to cancel the subscription\n    return this;\n};\n\nmodule.exports = Subscription;\n"]},"metadata":{},"sourceType":"script"}