{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file formatters.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\nvar _ = require('underscore');\n\nvar utils = require('web3-utils');\n\nvar BN = require('bn.js');\n\nvar SolidityParam = require('./param');\n/**\n * Formats input value to byte representation of int\n * If value is negative, return it's two's complement\n * If the value is floating point, round it down\n *\n * @method formatInputInt\n * @param {String|Number|BN} value that needs to be formatted\n * @returns {SolidityParam}\n */\n\n\nvar formatInputInt = function formatInputInt(value) {\n  if (_.isNumber(value)) {\n    value = Math.trunc(value);\n  }\n\n  return new SolidityParam(utils.toTwosComplement(value).replace('0x', ''));\n};\n/**\n * Formats input bytes\n *\n * @method formatInputBytes\n * @param {String} value\n * @returns {SolidityParam}\n */\n\n\nvar formatInputBytes = function formatInputBytes(value) {\n  if (!utils.isHexStrict(value)) {\n    throw new Error('Given parameter is not bytes: \"' + value + '\"');\n  }\n\n  var result = value.replace(/^0x/i, '');\n\n  if (result.length % 2 !== 0) {\n    throw new Error('Given parameter bytes has an invalid length: \"' + value + '\"');\n  }\n\n  if (result.length > 64) {\n    throw new Error('Given parameter bytes is too long: \"' + value + '\"');\n  }\n\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(result);\n};\n/**\n * Formats input bytes\n *\n * @method formatDynamicInputBytes\n * @param {String} value\n * @returns {SolidityParam}\n */\n\n\nvar formatInputDynamicBytes = function formatInputDynamicBytes(value) {\n  if (!utils.isHexStrict(value)) {\n    throw new Error('Given parameter is not bytes: \"' + value + '\"');\n  }\n\n  var result = value.replace(/^0x/i, '');\n\n  if (result.length % 2 !== 0) {\n    throw new Error('Given parameter bytes has an invalid length: \"' + value + '\"');\n  }\n\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n/**\n * Formats input value to byte representation of string\n *\n * @method formatInputString\n * @param {String}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputString = function formatInputString(value) {\n  if (!_.isString(value)) {\n    throw new Error('Given parameter is not a valid string: ' + value);\n  }\n\n  var result = utils.utf8ToHex(value).replace(/^0x/i, '');\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n/**\n * Formats input value to byte representation of bool\n *\n * @method formatInputBool\n * @param {Boolean}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputBool = function formatInputBool(value) {\n  var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ? '1' : '0');\n  return new SolidityParam(result);\n};\n/**\n * Check if input value is negative\n *\n * @method signedIsNegative\n * @param {String} value is hex format\n * @returns {Boolean} true if it is negative, otherwise false\n */\n\n\nvar signedIsNegative = function signedIsNegative(value) {\n  return new BN(value.substr(0, 1), 16).toString(2).substr(0, 1) === '1';\n};\n/**\n * Formats right-aligned output bytes to int\n *\n * @method formatOutputInt\n * @param {SolidityParam} param\n * @returns {BN} right-aligned output bytes formatted to big number\n */\n\n\nvar formatOutputInt = function formatOutputInt(param) {\n  var value = param.staticPart();\n\n  if (!value && !param.rawValue) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  } // check if it's negative number\n  // it it is, return two's complement\n\n\n  if (signedIsNegative(value)) {\n    return new BN(value, 16).fromTwos(256).toString(10);\n  }\n\n  return new BN(value, 16).toString(10);\n};\n/**\n * Formats right-aligned output bytes to uint\n *\n * @method formatOutputUInt\n * @param {SolidityParam} param\n * @returns {BN} right-aligned output bytes formatted to uint\n */\n\n\nvar formatOutputUInt = function formatOutputUInt(param, name) {\n  var value = param.staticPart();\n\n  if (!value && !param.rawValue) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  return new BN(value, 16).toString(10);\n};\n/**\n * Should be used to format output bool\n *\n * @method formatOutputBool\n * @param {SolidityParam} param\n * @param {String} name type name\n * @returns {Boolean} right-aligned input bytes formatted to bool\n */\n\n\nvar formatOutputBool = function formatOutputBool(param, name) {\n  var value = param.staticPart();\n\n  if (!value && !param.rawValue) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  return value === '0000000000000000000000000000000000000000000000000000000000000001';\n};\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputBytes\n * @param {SolidityParam} param left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\n\n\nvar formatOutputBytes = function formatOutputBytes(param, name) {\n  var matches = name.match(/^bytes([0-9]*)/);\n  var size = parseInt(matches[1]);\n\n  if (param.staticPart().slice(0, 2 * size).length !== size * 2) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue + ' The size doesn\\'t match.');\n  }\n\n  return '0x' + param.staticPart().slice(0, 2 * size);\n};\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputDynamicBytes\n * @param {SolidityParam} param left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\n\n\nvar formatOutputDynamicBytes = function formatOutputDynamicBytes(param, name) {\n  var hex = param.dynamicPart().slice(0, 64);\n\n  if (!hex) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  var length = new BN(hex, 16).toNumber() * 2;\n  return '0x' + param.dynamicPart().substr(64, length);\n};\n/**\n * Should be used to format output string\n *\n * @method formatOutputString\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} ascii string\n */\n\n\nvar formatOutputString = function formatOutputString(param) {\n  var hex = param.dynamicPart().slice(0, 64);\n\n  if (!hex) {\n    throw new Error('ERROR: The returned value is not a convertible string:' + hex);\n  }\n\n  var length = new BN(hex, 16).toNumber() * 2;\n  return length ? utils.hexToUtf8('0x' + param.dynamicPart().substr(64, length).replace(/^0x/i, '')) : '';\n};\n/**\n * Should be used to format output address\n *\n * @method formatOutputAddress\n * @param {SolidityParam} param right-aligned input bytes\n * @param {String} name type name\n * @returns {String} address\n */\n\n\nvar formatOutputAddress = function formatOutputAddress(param, name) {\n  var value = param.staticPart();\n\n  if (!value) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  return utils.toChecksumAddress(\"0x\" + value.slice(value.length - 40, value.length));\n};\n\nmodule.exports = {\n  formatInputInt: formatInputInt,\n  formatInputBytes: formatInputBytes,\n  formatInputDynamicBytes: formatInputDynamicBytes,\n  formatInputString: formatInputString,\n  formatInputBool: formatInputBool,\n  formatOutputInt: formatOutputInt,\n  formatOutputUInt: formatOutputUInt,\n  formatOutputBool: formatOutputBool,\n  formatOutputBytes: formatOutputBytes,\n  formatOutputDynamicBytes: formatOutputDynamicBytes,\n  formatOutputString: formatOutputString,\n  formatOutputAddress: formatOutputAddress,\n  toTwosComplement: utils.toTwosComplement\n};","map":{"version":3,"sources":["/Users/erick/eth/progpay/client/node_modules/drizzle/node_modules/web3-eth-abi/src/formatters.js"],"names":["_","require","utils","BN","SolidityParam","formatInputInt","value","isNumber","Math","trunc","toTwosComplement","replace","formatInputBytes","isHexStrict","Error","result","length","l","floor","padRight","formatInputDynamicBytes","formatInputString","isString","utf8ToHex","formatInputBool","signedIsNegative","substr","toString","formatOutputInt","param","staticPart","rawValue","name","fromTwos","formatOutputUInt","formatOutputBool","formatOutputBytes","matches","match","size","parseInt","slice","formatOutputDynamicBytes","hex","dynamicPart","toNumber","formatOutputString","hexToUtf8","formatOutputAddress","toChecksumAddress","module","exports"],"mappings":"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","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file formatters.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\n\nvar _ = require('underscore');\nvar utils = require('web3-utils');\nvar BN = require('bn.js');\nvar SolidityParam = require('./param');\n\n\n\n/**\n * Formats input value to byte representation of int\n * If value is negative, return it's two's complement\n * If the value is floating point, round it down\n *\n * @method formatInputInt\n * @param {String|Number|BN} value that needs to be formatted\n * @returns {SolidityParam}\n */\nvar formatInputInt = function (value) {\n    if(_.isNumber(value)) {\n        value = Math.trunc(value);\n    }\n    return new SolidityParam(utils.toTwosComplement(value).replace('0x',''));\n};\n\n/**\n * Formats input bytes\n *\n * @method formatInputBytes\n * @param {String} value\n * @returns {SolidityParam}\n */\nvar formatInputBytes = function (value) {\n    if(!utils.isHexStrict(value)) {\n        throw new Error('Given parameter is not bytes: \"'+ value + '\"');\n    }\n\n    var result = value.replace(/^0x/i,'');\n\n    if(result.length % 2 !== 0) {\n        throw new Error('Given parameter bytes has an invalid length: \"'+ value + '\"');\n    }\n\n    if (result.length > 64) {\n        throw new Error('Given parameter bytes is too long: \"' + value + '\"');\n    }\n\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(result);\n};\n\n/**\n * Formats input bytes\n *\n * @method formatDynamicInputBytes\n * @param {String} value\n * @returns {SolidityParam}\n */\nvar formatInputDynamicBytes = function (value) {\n    if(!utils.isHexStrict(value)) {\n        throw new Error('Given parameter is not bytes: \"'+ value + '\"');\n    }\n\n    var result = value.replace(/^0x/i,'');\n\n    if(result.length % 2 !== 0) {\n        throw new Error('Given parameter bytes has an invalid length: \"'+ value + '\"');\n    }\n\n    var length = result.length / 2;\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of string\n *\n * @method formatInputString\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputString = function (value) {\n    if(!_.isString(value)) {\n        throw new Error('Given parameter is not a valid string: ' + value);\n    }\n\n    var result = utils.utf8ToHex(value).replace(/^0x/i,'');\n    var length = result.length / 2;\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of bool\n *\n * @method formatInputBool\n * @param {Boolean}\n * @returns {SolidityParam}\n */\nvar formatInputBool = function (value) {\n    var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');\n    return new SolidityParam(result);\n};\n\n\n/**\n * Check if input value is negative\n *\n * @method signedIsNegative\n * @param {String} value is hex format\n * @returns {Boolean} true if it is negative, otherwise false\n */\nvar signedIsNegative = function (value) {\n    return (new BN(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';\n};\n\n/**\n * Formats right-aligned output bytes to int\n *\n * @method formatOutputInt\n * @param {SolidityParam} param\n * @returns {BN} right-aligned output bytes formatted to big number\n */\nvar formatOutputInt = function (param) {\n    var value = param.staticPart();\n\n    if(!value && !param.rawValue) {\n        throw new Error('Couldn\\'t decode '+ name +' from ABI: 0x'+ param.rawValue);\n    }\n\n    // check if it's negative number\n    // it it is, return two's complement\n    if (signedIsNegative(value)) {\n        return new BN(value, 16).fromTwos(256).toString(10);\n    }\n    return new BN(value, 16).toString(10);\n};\n\n/**\n * Formats right-aligned output bytes to uint\n *\n * @method formatOutputUInt\n * @param {SolidityParam} param\n * @returns {BN} right-aligned output bytes formatted to uint\n */\nvar formatOutputUInt = function (param, name) {\n    var value = param.staticPart();\n\n    if(!value && !param.rawValue) {\n        throw new Error('Couldn\\'t decode '+ name +' from ABI: 0x'+ param.rawValue);\n    }\n\n    return new BN(value, 16).toString(10);\n};\n\n\n\n/**\n * Should be used to format output bool\n *\n * @method formatOutputBool\n * @param {SolidityParam} param\n * @param {String} name type name\n * @returns {Boolean} right-aligned input bytes formatted to bool\n */\nvar formatOutputBool = function (param, name) {\n    var value = param.staticPart();\n\n    if(!value && !param.rawValue) {\n        throw new Error('Couldn\\'t decode '+ name +' from ABI: 0x'+ param.rawValue);\n    }\n\n    return (value === '0000000000000000000000000000000000000000000000000000000000000001');\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputBytes\n * @param {SolidityParam} param left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\nvar formatOutputBytes = function (param, name) {\n    var matches = name.match(/^bytes([0-9]*)/);\n    var size = parseInt(matches[1]);\n\n    if(param.staticPart().slice(0, 2 * size).length !== size * 2) {\n        throw new Error('Couldn\\'t decode '+ name +' from ABI: 0x'+ param.rawValue + ' The size doesn\\'t match.');\n    }\n\n    return '0x' + param.staticPart().slice(0, 2 * size);\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputDynamicBytes\n * @param {SolidityParam} param left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\nvar formatOutputDynamicBytes = function (param, name) {\n    var hex = param.dynamicPart().slice(0, 64);\n\n    if (!hex) {\n        throw new Error('Couldn\\'t decode '+ name +' from ABI: 0x'+ param.rawValue);\n    }\n\n    var length = (new BN(hex, 16)).toNumber() * 2;\n    return '0x' + param.dynamicPart().substr(64, length);\n};\n\n/**\n * Should be used to format output string\n *\n * @method formatOutputString\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} ascii string\n */\nvar formatOutputString = function (param) {\n    var hex = param.dynamicPart().slice(0, 64);\n\n    if(!hex) {\n        throw new Error('ERROR: The returned value is not a convertible string:'+ hex);\n    }\n\n    var length = (new BN(hex, 16)).toNumber() * 2;\n    return length ? utils.hexToUtf8('0x'+ param.dynamicPart().substr(64, length).replace(/^0x/i, '')) : '';\n};\n\n/**\n * Should be used to format output address\n *\n * @method formatOutputAddress\n * @param {SolidityParam} param right-aligned input bytes\n * @param {String} name type name\n * @returns {String} address\n */\nvar formatOutputAddress = function (param, name) {\n    var value = param.staticPart();\n\n    if (!value) {\n        throw new Error('Couldn\\'t decode '+ name +' from ABI: 0x'+ param.rawValue);\n    }\n\n    return utils.toChecksumAddress(\"0x\" + value.slice(value.length - 40, value.length));\n};\n\nmodule.exports = {\n    formatInputInt: formatInputInt,\n    formatInputBytes: formatInputBytes,\n    formatInputDynamicBytes: formatInputDynamicBytes,\n    formatInputString: formatInputString,\n    formatInputBool: formatInputBool,\n    formatOutputInt: formatOutputInt,\n    formatOutputUInt: formatOutputUInt,\n    formatOutputBool: formatOutputBool,\n    formatOutputBytes: formatOutputBytes,\n    formatOutputDynamicBytes: formatOutputDynamicBytes,\n    formatOutputString: formatOutputString,\n    formatOutputAddress: formatOutputAddress,\n    toTwosComplement: utils.toTwosComplement\n};\n"]},"metadata":{},"sourceType":"script"}