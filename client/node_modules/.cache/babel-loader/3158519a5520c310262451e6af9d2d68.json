{"ast":null,"code":"/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\nvar _ = require('underscore');\n\nvar utils = require('web3-utils');\n\nvar f = require('./formatters');\n\nvar SolidityTypeAddress = require('./types/address');\n\nvar SolidityTypeBool = require('./types/bool');\n\nvar SolidityTypeInt = require('./types/int');\n\nvar SolidityTypeUInt = require('./types/uint');\n\nvar SolidityTypeDynamicBytes = require('./types/dynamicbytes');\n\nvar SolidityTypeString = require('./types/string');\n\nvar SolidityTypeBytes = require('./types/bytes');\n\nvar isDynamic = function (solidityType, type) {\n  return solidityType.isDynamicType(type) || solidityType.isDynamicArray(type);\n}; // result method\n\n\nfunction Result() {}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\n\n\nvar ABICoder = function (types) {\n  this._types = types;\n};\n/**\n * This method should be used to transform type to SolidityType\n *\n * @method _requireType\n * @param {String} type\n * @returns {SolidityType}\n * @throws {Error} throws if no matching type is found\n */\n\n\nABICoder.prototype._requireType = function (type) {\n  var solidityType = this._types.filter(function (t) {\n    return t.isType(type);\n  })[0];\n\n  if (!solidityType) {\n    throw Error('Invalid solidity type: ' + type);\n  }\n\n  return solidityType;\n};\n\nABICoder.prototype._getOffsets = function (types, solidityTypes) {\n  var lengths = solidityTypes.map(function (solidityType, index) {\n    return solidityType.staticPartLength(types[index]);\n  });\n\n  for (var i = 1; i < lengths.length; i++) {\n    // sum with length of previous element\n    lengths[i] += lengths[i - 1];\n  }\n\n  return lengths.map(function (length, index) {\n    // remove the current length, so the length is sum of previous elements\n    var staticPartLength = solidityTypes[index].staticPartLength(types[index]);\n    return length - staticPartLength;\n  });\n};\n\nABICoder.prototype._getSolidityTypes = function (types) {\n  var self = this;\n  return types.map(function (type) {\n    return self._requireType(type);\n  });\n};\n\nABICoder.prototype._encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {\n  var result = \"\";\n  var self = this;\n  types.forEach(function (type, i) {\n    if (isDynamic(solidityTypes[i], types[i])) {\n      result += f.formatInputInt(dynamicOffset).encode();\n\n      var e = self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n\n      dynamicOffset += e.length / 2;\n    } else {\n      // don't add length to dynamicOffset. it's already counted\n      result += self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n    } // TODO: figure out nested arrays\n\n  });\n  types.forEach(function (type, i) {\n    if (isDynamic(solidityTypes[i], types[i])) {\n      var e = self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n\n      dynamicOffset += e.length / 2;\n      result += e;\n    }\n  });\n  return result;\n}; // TODO: refactor whole encoding!\n\n\nABICoder.prototype._encodeWithOffset = function (type, solidityType, encoded, offset) {\n  var self = this;\n\n  if (solidityType.isDynamicArray(type)) {\n    return function () {\n      // offset was already set\n      var nestedName = solidityType.nestedName(type);\n      var nestedStaticPartLength = solidityType.staticPartLength(nestedName);\n      var result = encoded[0];\n\n      (function () {\n        var previousLength = 2; // in int\n\n        if (solidityType.isDynamicArray(nestedName)) {\n          for (var i = 1; i < encoded.length; i++) {\n            previousLength += +encoded[i - 1][0] || 0;\n            result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();\n          }\n        }\n      })(); // first element is length, skip it\n\n\n      (function () {\n        for (var i = 0; i < encoded.length - 1; i++) {\n          var additionalOffset = result / 2;\n          result += self._encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset + additionalOffset);\n        }\n      })();\n\n      return result;\n    }();\n  } else if (solidityType.isStaticArray(type)) {\n    return function () {\n      var nestedName = solidityType.nestedName(type);\n      var nestedStaticPartLength = solidityType.staticPartLength(nestedName);\n      var result = \"\";\n\n      if (solidityType.isDynamicArray(nestedName)) {\n        (function () {\n          var previousLength = 0; // in int\n\n          for (var i = 0; i < encoded.length; i++) {\n            // calculate length of previous item\n            previousLength += +(encoded[i - 1] || [])[0] || 0;\n            result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();\n          }\n        })();\n      }\n\n      (function () {\n        for (var i = 0; i < encoded.length; i++) {\n          var additionalOffset = result / 2;\n          result += self._encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);\n        }\n      })();\n\n      return result;\n    }();\n  }\n\n  return encoded;\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\n\n\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\n\n\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n * @param {String} type\n * @param {Object} param\n * @return {String} encoded plain param\n */\n\n\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n * @param {Array} types\n * @param {Array} params\n * @return {String} encoded list of params\n */\n\n\nABICoder.prototype.encodeParameters = function (types, params) {\n  // given a json interface\n  if (_.isObject(types) && types.inputs) {\n    types = _.map(types.inputs, function (input) {\n      return input.type;\n    });\n  }\n\n  var solidityTypes = this._getSolidityTypes(types);\n\n  var encodeds = solidityTypes.map(function (solidityType, index) {\n    return solidityType.encode(params[index], types[index]);\n  });\n  var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {\n    var staticPartLength = solidityType.staticPartLength(types[index]);\n    var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;\n    return acc + (isDynamic(solidityTypes[index], types[index]) ? 32 : roundedStaticPartLength);\n  }, 0);\n  return '0x' + this._encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\n\n\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\n\n\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  if (!_.isString(type)) {\n    throw new Error('Given parameter type is not a string: ' + type);\n  }\n\n  return this.decodeParameters([{\n    type: type\n  }], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\n\n\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  var isTypeArray = _.isArray(outputs) && _.isString(outputs[0]);\n\n  var types = isTypeArray ? outputs : [];\n\n  if (!isTypeArray) {\n    outputs.forEach(function (output) {\n      types.push(output.type);\n    });\n  }\n\n  var solidityTypes = this._getSolidityTypes(types);\n\n  var offsets = this._getOffsets(types, solidityTypes);\n\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  var count = 0;\n  outputs.forEach(function (output, i) {\n    var decodedValue = solidityTypes[count].decode(bytes.replace(/^0x/i, ''), offsets[count], types[count], count);\n    decodedValue = decodedValue === '0x' ? null : decodedValue;\n    returnValue[i] = decodedValue;\n\n    if (_.isObject(output) && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n\n    returnValue.__length__++;\n    count++;\n  });\n  return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * * @param {Array} topics\n * @return {Array} array of plain params\n */\n\n\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  data = data || '';\n  var notIndexedInputs = [];\n  var indexedInputs = [];\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedInputs[i] = input;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  var nonIndexedData = data.slice(2);\n  var indexedData = _.isArray(topics) ? topics.map(function (topic) {\n    return topic.slice(2);\n  }).join('') : topics;\n  var notIndexedParams = this.decodeParameters(notIndexedInputs, nonIndexedData);\n  var indexedParams = this.decodeParameters(indexedInputs, indexedData);\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n\n    if (notIndexedParams[i]) {\n      returnValue[i] = notIndexedParams[i];\n    }\n\n    if (indexedParams[i]) {\n      returnValue[i] = indexedParams[i];\n    }\n\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n\nvar coder = new ABICoder([new SolidityTypeAddress(), new SolidityTypeBool(), new SolidityTypeInt(), new SolidityTypeUInt(), new SolidityTypeDynamicBytes(), new SolidityTypeBytes(), new SolidityTypeString()]);\nmodule.exports = coder;","map":{"version":3,"sources":["/Users/erick/eth/progpay/client/node_modules/drizzle/node_modules/web3-eth-abi/src/index.js"],"names":["_","require","utils","f","SolidityTypeAddress","SolidityTypeBool","SolidityTypeInt","SolidityTypeUInt","SolidityTypeDynamicBytes","SolidityTypeString","SolidityTypeBytes","isDynamic","solidityType","type","isDynamicType","isDynamicArray","Result","ABICoder","types","_types","prototype","_requireType","filter","t","isType","Error","_getOffsets","solidityTypes","lengths","map","index","staticPartLength","i","length","_getSolidityTypes","self","_encodeMultiWithOffset","encodeds","dynamicOffset","result","forEach","formatInputInt","encode","e","_encodeWithOffset","encoded","offset","nestedName","nestedStaticPartLength","previousLength","additionalOffset","isStaticArray","encodeFunctionSignature","functionName","isObject","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","encodeParameter","param","encodeParameters","params","inputs","input","reduce","acc","roundedStaticPartLength","Math","floor","encodeFunctionCall","jsonInterface","replace","decodeParameter","bytes","isString","decodeParameters","outputs","isTypeArray","isArray","output","push","offsets","returnValue","__length__","count","decodedValue","decode","name","decodeLog","data","topics","notIndexedInputs","indexedInputs","indexed","nonIndexedData","indexedData","topic","join","notIndexedParams","indexedParams","res","coder","module","exports"],"mappings":"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","sourcesContent":["/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\n\nvar _ = require('underscore');\nvar utils = require('web3-utils');\n\nvar f = require('./formatters');\n\nvar SolidityTypeAddress = require('./types/address');\nvar SolidityTypeBool = require('./types/bool');\nvar SolidityTypeInt = require('./types/int');\nvar SolidityTypeUInt = require('./types/uint');\nvar SolidityTypeDynamicBytes = require('./types/dynamicbytes');\nvar SolidityTypeString = require('./types/string');\nvar SolidityTypeBytes = require('./types/bytes');\n\nvar isDynamic = function (solidityType, type) {\n    return solidityType.isDynamicType(type) ||\n        solidityType.isDynamicArray(type);\n};\n\n\n// result method\nfunction Result() {}\n\n\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function (types) {\n    this._types = types;\n};\n\n/**\n * This method should be used to transform type to SolidityType\n *\n * @method _requireType\n * @param {String} type\n * @returns {SolidityType}\n * @throws {Error} throws if no matching type is found\n */\nABICoder.prototype._requireType = function (type) {\n    var solidityType = this._types.filter(function (t) {\n        return t.isType(type);\n    })[0];\n\n    if (!solidityType) {\n        throw Error('Invalid solidity type: ' + type);\n    }\n\n    return solidityType;\n};\n\n\n\nABICoder.prototype._getOffsets = function (types, solidityTypes) {\n    var lengths =  solidityTypes.map(function (solidityType, index) {\n        return solidityType.staticPartLength(types[index]);\n    });\n\n    for (var i = 1; i < lengths.length; i++) {\n        // sum with length of previous element\n        lengths[i] += lengths[i - 1];\n    }\n\n    return lengths.map(function (length, index) {\n        // remove the current length, so the length is sum of previous elements\n        var staticPartLength = solidityTypes[index].staticPartLength(types[index]);\n        return length - staticPartLength;\n    });\n};\n\nABICoder.prototype._getSolidityTypes = function (types) {\n    var self = this;\n    return types.map(function (type) {\n        return self._requireType(type);\n    });\n};\n\n\nABICoder.prototype._encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {\n    var result = \"\";\n    var self = this;\n\n    types.forEach(function (type, i) {\n        if (isDynamic(solidityTypes[i], types[i])) {\n            result += f.formatInputInt(dynamicOffset).encode();\n            var e = self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n            dynamicOffset += e.length / 2;\n        } else {\n            // don't add length to dynamicOffset. it's already counted\n            result += self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n        }\n\n        // TODO: figure out nested arrays\n    });\n\n    types.forEach(function (type, i) {\n        if (isDynamic(solidityTypes[i], types[i])) {\n            var e = self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n            dynamicOffset += e.length / 2;\n            result += e;\n        }\n    });\n    return result;\n};\n\n// TODO: refactor whole encoding!\nABICoder.prototype._encodeWithOffset = function (type, solidityType, encoded, offset) {\n    var self = this;\n    if (solidityType.isDynamicArray(type)) {\n        return (function () {\n            // offset was already set\n            var nestedName = solidityType.nestedName(type);\n            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);\n            var result = encoded[0];\n\n            (function () {\n                var previousLength = 2; // in int\n                if (solidityType.isDynamicArray(nestedName)) {\n                    for (var i = 1; i < encoded.length; i++) {\n                        previousLength += +(encoded[i - 1])[0] || 0;\n                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();\n                    }\n                }\n            })();\n\n            // first element is length, skip it\n            (function () {\n                for (var i = 0; i < encoded.length - 1; i++) {\n                    var additionalOffset = result / 2;\n                    result += self._encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset +  additionalOffset);\n                }\n            })();\n\n            return result;\n        })();\n\n    } else if (solidityType.isStaticArray(type)) {\n        return (function () {\n            var nestedName = solidityType.nestedName(type);\n            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);\n            var result = \"\";\n\n\n            if (solidityType.isDynamicArray(nestedName)) {\n                (function () {\n                    var previousLength = 0; // in int\n                    for (var i = 0; i < encoded.length; i++) {\n                        // calculate length of previous item\n                        previousLength += +(encoded[i - 1] || [])[0] || 0;\n                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();\n                    }\n                })();\n            }\n\n            (function () {\n                for (var i = 0; i < encoded.length; i++) {\n                    var additionalOffset = result / 2;\n                    result += self._encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);\n                }\n            })();\n\n            return result;\n        })();\n    }\n\n    return encoded;\n};\n\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if(_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName).slice(0, 10);\n};\n\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if(_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName);\n};\n\n\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n * @param {String} type\n * @param {Object} param\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n * @param {Array} types\n * @param {Array} params\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    // given a json interface\n    if(_.isObject(types) && types.inputs) {\n        types = _.map(types.inputs, function (input) {\n            return input.type;\n        });\n    }\n\n    var solidityTypes = this._getSolidityTypes(types);\n\n    var encodeds = solidityTypes.map(function (solidityType, index) {\n        return solidityType.encode(params[index], types[index]);\n    });\n\n    var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {\n        var staticPartLength = solidityType.staticPartLength(types[index]);\n        var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;\n\n        return acc + (isDynamic(solidityTypes[index], types[index]) ?\n                32 :\n                roundedStaticPartLength);\n    }, 0);\n\n    return '0x'+ this._encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);\n};\n\n\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface, params).replace('0x','');\n};\n\n\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n\n    if (!_.isString(type)) {\n        throw new Error('Given parameter type is not a string: '+ type);\n    }\n\n    return this.decodeParameters([{type: type}], bytes)[0];\n};\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    var isTypeArray = _.isArray(outputs) && _.isString(outputs[0]);\n    var types = (isTypeArray) ? outputs : [];\n\n    if(!isTypeArray) {\n        outputs.forEach(function (output) {\n            types.push(output.type);\n        });\n    }\n\n    var solidityTypes = this._getSolidityTypes(types);\n    var offsets = this._getOffsets(types, solidityTypes);\n\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    var count = 0;\n\n    outputs.forEach(function (output, i) {\n        var decodedValue = solidityTypes[count].decode(bytes.replace(/^0x/i,''), offsets[count],  types[count], count);\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n\n        returnValue[i] = decodedValue;\n\n        if (_.isObject(output) && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n        count++;\n    });\n\n    return returnValue;\n};\n\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n\n    data = data || '';\n\n    var notIndexedInputs = [];\n    var indexedInputs = [];\n\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedInputs[i] = input;\n        } else {\n            notIndexedInputs[i] = input;\n        }\n    });\n\n    var nonIndexedData = data.slice(2);\n    var indexedData = _.isArray(topics) ? topics.map(function (topic) { return topic.slice(2); }).join('') : topics;\n\n    var notIndexedParams = this.decodeParameters(notIndexedInputs, nonIndexedData);\n    var indexedParams = this.decodeParameters(indexedInputs, indexedData);\n\n\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n\n        if (notIndexedParams[i]) {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (indexedParams[i]) {\n            returnValue[i] = indexedParams[i];\n        }\n\n        if(res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\n\nvar coder = new ABICoder([\n    new SolidityTypeAddress(),\n    new SolidityTypeBool(),\n    new SolidityTypeInt(),\n    new SolidityTypeUInt(),\n    new SolidityTypeDynamicBytes(),\n    new SolidityTypeBytes(),\n    new SolidityTypeString()\n]);\n\nmodule.exports = coder;\n"]},"metadata":{},"sourceType":"script"}